# 클라이언트 사이드 렌더링(CSR, Client Side Rendering)과 서버 사이드 렌더링(SSR, Server Side Rendering)

* 웹 페이지 렌더링 방식에 따른 분류
* 어떤 기술들에 대해 살피기 위해서는 그 기술이 등장한 원인부터 먼저 따지고 그 특징을 살펴보아야 한다고 생각. 
* 우선 어떤 배경에서 이러한 기술들이 등장하였는지 역사적으로 살펴볼 것. 

>SPA, CSR, SSR, SSG, TTV, TTI
---

## 웹의 역사

### 1990년대 중반 => 정적 웹사이트

* 1990년대 중반까지는 모두 정적 웹사이트 사용.(Static Sites)
* HTML 문서를이 이미 만들어져 있고 그것을 통쨰로 서버에서 받아오는 방식.
* 간단하게 예를 들자면 A4용지에다 페이지별로 이미 완성된 그림들을 그려놓고 그걸 하나씩 불러오는 방식
* 완성된 그림들에 점이 하나만 찍히더라도 점이 찍히기 전의 그림과 찍힌 후의 그림은 전혀 다른것으로 취급
* 따라서 페이지 간의 이동할때 1부터 10까지 전부 다 업데이트가 되어야 하는 것이고, 그만큼 페이지간 이동 속도나 사용자 편의성 면에서 효율이 금감하게 됨. 
* 페이지 넘길때마다 깜빡임이 발생하는 이유 중 하나. 

### 1996년: iframe 태그 도입
* 정적웹사이트랑은 조금 다른게 페이지 안에 페이지를 삽입하게 만든 것. 그러니깐 원본 페이지 div 박스가 하나 있다고 생각하면 그 안에 div 박스를 하나 더 만들어서 거 부분만 변경을 시켜주는것. 
* 물론 div 박스는 각각이 HTML 파일이라고 할 수 있다. 
* 지금도 종종 쓰이는 방식으로 블로그 내 영상이라던가 지도를 불러올때 활용. 

### 1998년부터 ~ :  XMLHttpRequest
* 프론트엔드 개발시 자주 쓰이는 Fetch API의 원조인 XHR Web API가 개발되어 HTML문서 전체가 아닌 JSON과 같은 포맷을 통해 서버에서 필요한 정보만 골라서 받아올 수 있게 변함. 
* 해당 데이터를 JavaScript를 이용해서 동적으로 HTML 요소를 생성한 후 페이지에 업데이트를 하는 방식. 


### 2005년: AJAX
* XHR 방식이 공식적으로 AJAX라는 이름을 가지게 됨. 
* AJAX 방식을 이용해서 Gmail이나 카카오 맵 같은 웹앱들이 생산되기 시작.

* 이렇게 한 페이지 내에 머무르면서 필요한 데이터만 받아와 업데이트 하는 방식을 **SPA(Single Page Application)** 라고 한다.

사실상 이렇게 하나의 어플리케이션을 사용하는 방식으로 웹 사이트를 구성하다보니, 이 방식이 이젠 표준화가 되었고 SPA 방식을 베이스로 여러가지 렌더링 방식이 등장.

---

## CSR(Client Side Rendering)
* 클라이언트 사이드 렌더링. 
* 말 그대로 클라이언트 쪽에서 렌더링을 진행하는 방식을 말함. 클라이언트(브라우저)에서 다해먹는것.

* 예를 들자면...
    ```html
    <!DOCTYPE html>
    <html lang="ko">
      <head>
        <meta charset="utf-8" />
        <meta
          name="description"
          content="Web site"
        />
        <title>App</title>
      </head>
      <body>
        <div id="root"></div>
        <script src="app.js"></script>
      </body>
    </html>
    ```
    대충 이런 방식으로 html은 텅 비어있고 거기에 달랑 `app.js`라고 JavaScript 파일만 연결되어 있음.
* HTML이 텅 비어 있기 때문에 첫화면은 빈화면만 보이고 그 후 링크된 `app.js`를 서버에서 다운로드 하는 것.

#### 작동방식
![CSR](https://www.sarah-note.com/static/2b2c814f10a5726eac67db95d5d625e9/3acf0/p1_csr.jpg)

### 작동 순서
1. 클라이언트가 서버에 접속한다
2. 서버에서 빈 index 파일을 받아온다 (Html파일에 태그와 js 링크가 비워져 있는 상황) == 빈 화면
3. 해당 웹 앱에 필요한 모든 로직이 담긴 JS 파일 요청 == 여전히 빈 화면
4. 동적으로 HTML을 생성할 수 있는 웹 앱 로직이 담긴 JS 파일을 받아옴. => 웹 사이트 노출, 상호작용. 

### CSR 장점
1. 필요한 데이터만 백엔드에서 가져오기 떄문에 서버 부하가 덜하다. 

### CSR 문제점
1. HTML 파일이 텅 비어있다
   * SEO(Search Engine Optimize)가 낮음. 검색엔진에서 검출되기가 함듬. 
   * 하지만 구글은 킹왕짱 검색엔진이라 딱히 이 문제가 크게 발행하지 않음. 
2. 빈 HTML 파일에 JS파일을 가져와 붙이는 방식으로 페이지를 렌더링
   * 첫 화면 초기화까지 로딩시간이 좀 걸림(많이 걸림).

### 용도
* 색인이 썩 중요하지 않은 상황
  * 관리자 페이지라던가 사용자 경험이 중요한 카카오맵 같은 웹앱

---

## SSR(Server Side Rendering)
* 서버 사이드 렌더링
* 말 그대로 서버 쪽에서 렌더링을 진행하는 방식. 
* 웹 사이트에 접속하면 **서버에서** 필요한 데이터를 모두 가져와서 HTML 파일을 만들게 되고 이렇게 만들어진 파일을 동적으로 제어할 수 있는 약간의 자바스크립트 소스 코드와 함께 클라이언트에게 보내준다.
* CSR 방식에서 정적 웹페이지 방식을 참고한 셈. 


![SSR](https://www.sarah-note.com/static/862e8950181629369ee391b5e4a11578/3acf0/p1_ssr.jpg)

### 동작 순서
1. 클라이언트가 사이트에 접속
2. 서버에서 이미 잘 만들어진 index 파일을 가져온다. => 웹 사이트 노출
3. 동적으로 제어가능한 로직이 담긴 링크된 JS 파일 요청 => 웹 사이트 노출
4. 사용자와 상호작용이 가능한 JS 파일을 받아옴=> 웹 사이트 노출, 상호작용

### SSR 장점 (SCR에서 발생한 문제 해결)
1. 페이지를 초기화 할때 로딩이 빠름. (서버에서 로딩 다하고 넘어오니까)
2. 애초부터 서버에서 받아오는 HTML 파일에 모든 정보가 담겨있기에 효율적인 SEO를 기대 가능.

### SSR 문제점
1. 정적 웹페이지 사이트에서 발생하던 **깜빡임 이슈**(Blinking Issue)가 존재. 
2. 정적 웹페이지 사이트와 유사하게 서버에 **과부하가 걸리기 쉬움**. (받아오는 파일의 사이즈가 크니까.)
   * 과부하가 걸리게되면 HTML 파일은 넘어왔는데 JS파일이 못넘어와서 화면 동작이 멈추는 경우가 발생.
3. TTV(Time To View)와 TVI(Time To Interact)의 공백시간 존재

> **TTV**
>   사용자가 웹 페이지를 볼 수 있는 시점 
> 
> **TVI**
>   사용자가 웹 페이지와 상호작용 할 수 있는(웹페이지를 사용할 수 있는) 시점

### 용도
* 검색엔진의 색인이 필요한 경우
* 컨텐츠가 주를 이루는 뉴스나 강의 페이지 같은 경우.

---

## 정리

1. CSR은 클라이언트 측에서 페이지를 생성하는 방식
   * 빈 HTML 화면에서 데이터를 하나씩 서버에서 받아와 붙이는 방식이기에 검색엔진에 걸리지 않는 경우가 많음. 
   * 데이터를 하나하나 받아오기에 로딩시간이 오래걸림
2. SSR은 서버측에서 페이지를 생성하는 방식
   * 클라이언트 측에서 필요한 데이터를 서버에 요청하면 서버에서 이를 기반으로 HTML을 생성하여 클라이언트에 넘겨줌
   * 로딩시간이 CSR에 비해 줄어듬
   * 정적 페이지 방식과 유사하여 깜박임 문제(Blinking issue)가 여전히 존재. 
   * 서버 과부하 문제가 발생 가능성 존재
   * HTML을 받고 JS파일들은 하나씩 넘겨받는데다 사용자가 웹페이지와 상호작용을 하기 위한 JS 파일의 우선순위는 가장 낮기에 과부하 문제가 발생하면 이 파일들을 제대로 받아오지 못하는 경우 발생. 화면 먹통상황